# Sort



## Selection Sort

----

가장 큰 값을 찾은 이후 맨 마지막으로 보낸다.

그 다음 가장 큰 값을 찾은 이후 맨 마지막으로 보낸다.

마지막 두개의 데이터가 남을 때까지 반복...

시간 복잡도는 0(n^2)



## Bubble Sort

---

첫번째 부터 시작해서 다음 값과 비교

큰 값을 계속해서 뒤로 오도록 자리 바꿈

결국 가장 큰 값이 맨 뒤로 오게됨

한바퀴가 이루어지면 다시 처음부터 시작

시간 복잡도는 0(n^2)



## Insertion Sort

---

첫번째 데이터는 정렬되었다고 가정

두번째 부터 첫번째를 기준으로 정렬

세번째는 첫번째, 두번째를 기준으로 정렬

그렇게 뒤로 쭉 하나씩 나아가는 방법

k-1 까지는 정렬되어 있다고 가정 / k 를 끼워 넣는 방식

시간 복잡도는 0(n^2) -> 최악의 경우에 



## Merge Sort

---

분할 - 해결해고자 하는 문제를 더 작은 크기의 **동일한** 문제로 분할

정복 - 작은문를 순환적으로 해결

1. 데이터를 두개로 나눈다.
2. 각각을 순환적으로 정렬
3. 정렬된 두 개의 배열을 합침



하나로 합치는 merge 과정이 제일 중요하다.

합병을 할때는 각각의 가장 작은 값이 있는 제일 앞꺼만 비교

가장 작은값 본체로 오고 다시 가장 작은 값이 있는 앞의 값 비교 

반복



데이터를 정리할 때 다른 배열이 필요하다.

T(n) = T(n/2) + T(n/2) + n

데이터가 n 개면 반으로 쪼개거 두번하고 머지하는 n

O(n log n)

